{"ast":null,"code":"\"client\";\n\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/philipslee/final panda/client/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"C:/Users/philipslee/final panda/client/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports.default = void 0;\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\nvar _interop_require_wildcard = require(\"@swc/helpers/lib/_interop_require_wildcard.js\").default;\nvar _object_without_properties_loose = require(\"@swc/helpers/lib/_object_without_properties_loose.js\").default;\nvar _react = _interop_require_wildcard(require(\"react\"));\nvar _headManagerContext = require(\"../shared/lib/head-manager-context\");\nvar _headManager = require(\"./head-manager\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n'client';\nvar ScriptCache = new Map();\nvar LoadCache = new Set();\nvar ignoreProps = ['onLoad', 'onReady', 'dangerouslySetInnerHTML', 'children', 'onError', 'strategy'];\nvar loadScript = function loadScript(props) {\n  var src = props.src,\n    id = props.id,\n    _props$onLoad = props.onLoad,\n    onLoad = _props$onLoad === void 0 ? function () {} : _props$onLoad,\n    _props$onReady = props.onReady,\n    onReady = _props$onReady === void 0 ? null : _props$onReady,\n    dangerouslySetInnerHTML = props.dangerouslySetInnerHTML,\n    _props$children = props.children,\n    children = _props$children === void 0 ? '' : _props$children,\n    _props$strategy = props.strategy,\n    strategy = _props$strategy === void 0 ? 'afterInteractive' : _props$strategy,\n    onError = props.onError;\n  var cacheKey = id || src;\n  // Script has already loaded\n  if (cacheKey && LoadCache.has(cacheKey)) {\n    return;\n  }\n  // Contents of this script are already loading/loaded\n  if (ScriptCache.has(src)) {\n    LoadCache.add(cacheKey);\n    // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n    // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n    ScriptCache.get(src).then(onLoad, onError);\n    return;\n  }\n  /** Execute after the script first loaded */\n  var afterLoad = function afterLoad() {\n    // Run onReady for the first time after load event\n    if (onReady) {\n      onReady();\n    }\n    // add cacheKey to LoadCache when load successfully\n    LoadCache.add(cacheKey);\n  };\n  var el = document.createElement('script');\n  var loadPromise = new Promise(function (resolve, reject) {\n    el.addEventListener('load', function (e) {\n      resolve();\n      if (onLoad) {\n        onLoad.call(this, e);\n      }\n      afterLoad();\n    });\n    el.addEventListener('error', function (e) {\n      reject(e);\n    });\n  }).catch(function (e) {\n    if (onError) {\n      onError(e);\n    }\n  });\n  if (dangerouslySetInnerHTML) {\n    el.innerHTML = dangerouslySetInnerHTML.__html || '';\n    afterLoad();\n  } else if (children) {\n    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n    afterLoad();\n  } else if (src) {\n    el.src = src;\n    // do not add cacheKey into LoadCache for remote script here\n    // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n    ScriptCache.set(src, loadPromise);\n  }\n  for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      k = _Object$entries$_i[0],\n      value = _Object$entries$_i[1];\n    if (value === undefined || ignoreProps.includes(k)) {\n      continue;\n    }\n    var attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n    el.setAttribute(attr, value);\n  }\n  if (strategy === 'worker') {\n    el.setAttribute('type', 'text/partytown');\n  }\n  el.setAttribute('data-nscript', strategy);\n  document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n  var _props$strategy2 = props.strategy,\n    strategy = _props$strategy2 === void 0 ? 'afterInteractive' : _props$strategy2;\n  if (strategy === 'lazyOnload') {\n    window.addEventListener('load', function () {\n      (0, _requestIdleCallback).requestIdleCallback(function () {\n        return loadScript(props);\n      });\n    });\n  } else {\n    loadScript(props);\n  }\n}\nfunction loadLazyScript(props) {\n  if (document.readyState === 'complete') {\n    (0, _requestIdleCallback).requestIdleCallback(function () {\n      return loadScript(props);\n    });\n  } else {\n    window.addEventListener('load', function () {\n      (0, _requestIdleCallback).requestIdleCallback(function () {\n        return loadScript(props);\n      });\n    });\n  }\n}\nfunction addBeforeInteractiveToCache() {\n  var scripts = [].concat(_toConsumableArray(document.querySelectorAll('[data-nscript=\"beforeInteractive\"]')), _toConsumableArray(document.querySelectorAll('[data-nscript=\"beforePageRender\"]')));\n  scripts.forEach(function (script) {\n    var cacheKey = script.id || script.getAttribute('src');\n    LoadCache.add(cacheKey);\n  });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n  scriptLoaderItems.forEach(handleClientScriptLoad);\n  addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n  var id = props.id,\n    _props$src = props.src,\n    src = _props$src === void 0 ? '' : _props$src,\n    _props$onLoad2 = props.onLoad,\n    onLoad = _props$onLoad2 === void 0 ? function () {} : _props$onLoad2,\n    _props$onReady2 = props.onReady,\n    onReady = _props$onReady2 === void 0 ? null : _props$onReady2,\n    _props$strategy3 = props.strategy,\n    strategy = _props$strategy3 === void 0 ? 'afterInteractive' : _props$strategy3,\n    onError = props.onError,\n    restProps = _object_without_properties_loose(props, [\"id\", \"src\", \"onLoad\", \"onReady\", \"strategy\", \"onError\"]);\n  // Context is available only during SSR\n  var _useContext = (0, _react).useContext(_headManagerContext.HeadManagerContext),\n    updateScripts = _useContext.updateScripts,\n    scripts = _useContext.scripts,\n    getIsSsr = _useContext.getIsSsr;\n  /**\n  * - First mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n  *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n  *      Once the script is loaded, the onLoad and onReady will be called by then\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  *\n  * - Second mount:\n  *   1. The useEffect for onReady executes\n  *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n  *      onReady is called, set hasOnReadyEffectCalled.current to true\n  *   3. The useEffect for loadScript executes\n  *   4. The script is already loaded, loadScript bails out\n  *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n  *   5. The useEffect for onReady executes again\n  *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n  *   7. The useEffect for loadScript executes again\n  *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n  */\n  var hasOnReadyEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(function () {\n    var cacheKey = id || src;\n    if (!hasOnReadyEffectCalled.current) {\n      // Run onReady if script has loaded before but component is re-mounted\n      if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n        onReady();\n      }\n      hasOnReadyEffectCalled.current = true;\n    }\n  }, [onReady, id, src]);\n  var hasLoadScriptEffectCalled = (0, _react).useRef(false);\n  (0, _react).useEffect(function () {\n    if (!hasLoadScriptEffectCalled.current) {\n      if (strategy === 'afterInteractive') {\n        loadScript(props);\n      } else if (strategy === 'lazyOnload') {\n        loadLazyScript(props);\n      }\n      hasLoadScriptEffectCalled.current = true;\n    }\n  }, [props, strategy]);\n  if (strategy === 'beforeInteractive' || strategy === 'worker') {\n    if (updateScripts) {\n      scripts[strategy] = (scripts[strategy] || []).concat([_extends({\n        id: id,\n        src: src,\n        onLoad: onLoad,\n        onReady: onReady,\n        onError: onError\n      }, restProps)]);\n      updateScripts(scripts);\n    } else if (getIsSsr && getIsSsr()) {\n      // Script has already loaded during SSR\n      LoadCache.add(id || src);\n    } else if (getIsSsr && !getIsSsr()) {\n      loadScript(props);\n    }\n  }\n  return null;\n}\nObject.defineProperty(Script, '__nextScript', {\n  value: true\n});\nvar _default = Script;\nexports.default = _default;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":"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","names":["initScriptLoader","ScriptCache","LoadCache","Set","ignoreProps","loadScript","id","props","onLoad","cacheKey","src","onReady","dangerouslySetInnerHTML","children","strategy","onError","add","afterLoad","loadPromise","createElement","resolve","reject","addEventListener","Promise","call","el","catch","e","textContent","undefined","includes","value","setAttribute","document","appendChild","handleClientScriptLoad","window","requestIdleCallback","readyState","_requestIdleCallback","addBeforeInteractiveToCache","querySelectorAll","scripts","script","scriptLoaderItems","forEach","Script","restProps","updateScripts","getIsSsr","useEffect","_react","hasOnReadyEffectCalled","hasLoadScriptEffectCalled","loadLazyScript","Object"],"sources":["../../client/script.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}